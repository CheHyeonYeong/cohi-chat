# 소프트웨어 테스팅 가이드

## 목차
1. [테스팅 개요](#테스팅-개요)
2. [테스팅 종류](#테스팅-종류)
3. [테스트 더블](#테스트-더블)
4. [pytest 사용법](#pytest-사용법)

---

## 테스팅 개요

### 테스팅이란?

소프트웨어 개발 과정에서 **테스팅(testing)**은 제품 또는 서비스가 올바르게 동작하는지, 요구 사항에 부합하는지를 확인하고 예상치 못한 결함이나 오류를 사전에 발견하여 개선하는 개발 절차입니다.

특히 애자일(Agile) 개발 환경에서는 코드 변경이 빈번하고 배포가 잦아 테스트를 자동화하여 서비스 품질을 지속적으로 확보하는 것이 필수입니다.

### 테스팅의 목적

테스팅은 주로 다음 목적으로 사용합니다:

#### 1. 품질 보증 (Quality Assurance)
결함을 조기에 발견하고 수정하여 높은 수준의 품질을 유지합니다.

#### 2. 회귀 방지 (Regression Avoidance)
기존 코드를 변경해도 이전에 작동하던 기능이 깨지지 않도록 예방합니다.

#### 3. 개발 속도 향상
자동화된 테스트가 구축되어 있으면 변경 사항을 빠르게 검증할 수 있어 개발 사이클이 빨라집니다.

### 테스팅의 중요성

#### 안전한 리팩터링과 구현 변경
- 자신감 있게 코드를 리팩터링하고, 새로운 기능을 추가하며, 장애 발생 가능성을 최소화하도록 돕습니다.

#### 문서화 역할
- 테스트 코드는 요구 사항을 명확하게 표현하는 '살아 있는 문서'로, 다른 개발자나 유지 보수 담당자가 시스템 동작 방식을 쉽게 이해할 수 있습니다.

### 테스팅 필요성

테스팅은 소프트웨어 개발 과정에서 선택 사항이 아닌 필수 요소라고 할 수 있습니다.

각각 기본적인 이유는 소프트웨어가 복잡해질수록 예상치 못한 동작이나 결함이 발생할 확률이 커지기 때문이지요. 특히 애플리케이션이 다양한 플랫폼, 네트워크 환경, 사용자 입력 패턴 등으로 상호 작용하는 과정이 늘어날수록 변동성은 커집니다.

이런 상황에서 테스팅은 새로운 코드를 추가하거나 기존 로직을 수정하는 과정에서 발생할 수 있는 오류를 사전에 식별하고 해결하여 불필요한 유지 보수 비용과 시간 낭비를 효과적으로 줄여 줍니다.

또 테스팅은 단순히 결함을 찾는 행위를 넘어 신뢰성과 안정성을 보장하는 도대가 됩니다. 사용자는 안정적인 경험을 기대하며, 이를 충족하는지 검증하는 단계가 바로 테스팅입니다.

일관된 테스트 프로세스로 개발 팀은 서비스 변경 사항을 자신 있게 배포할 수 있어 잦은 업데이터나 신기능 추가에도 기존 기능이 훼손되지 않는다는 심리적 안정감을 얻습니다. 이는 요구 사항 충족과 비즈니스 목표 달성으로 이어져 궁극적으로 제품 가치의 증대와 고객 만족도 상승에 기여할 것입니다.

---

## 테스팅 종류

테스팅에는 여러 종류가 있습니다. 각 테스트를 간단히 알아보고 뒷부분에서 이어서 살펴볼 것입니다.

### 단위 테스트 (Unit Test)

**단위 테스트**는 소프트웨어의 가장 작은 단위(함수, 메서드, 클래스) 수준에서 개별 로직이 제대로 동작하는지 검증합니다.

외부 의존성을 최소화한 상태에서 순수한 로직을 검증하므로 버그 위치를 빠르게 파악하고 수정할 수 있습니다.

**특징:**
- 가장 작은 단위의 코드를 독립적으로 검증
- 외부 의존성(DB, API 등) 제거 후 테스트
- 빠른 실행 속도

**예시:**
```python
# 예시: add(299792000, 458) 함수를 실행하면
# 299792458을 반환하는지 확인하지요.
# 원자적이고 간단하기 때문에 빠르게 실행되며,
# 결함 위치를 식별하기 용이하고, 변경에 따른 영향도 파악하기 쉽습니다.
# 주로 비즈니스 로직 함수나 유틸리티 함수를 검증할 때 사용합니다.
```

### 통합 테스트 (Integration Test)

**통합 테스트**는 서로 다른 모듈이나 컴포넌트(예: 데이터베이스, 외부 API, 파일 시스템)를 연계했을 때 전체 시스템이 일관성 있게 동작하는지 검증합니다.

단위 테스트로 각각의 모듈이 정상 동작을 검증했다면 통합 테스트는 이들이 조합되었을 때 의도한 결과를 낳는지 확인합니다.

**특징:**
- 여러 모듈/컴포넌트 간의 상호작용 검증
- 실제 DB, API, 파일 시스템 등과 연동
- 단위 테스트보다 느리지만 실제 환경과 유사

**예시:**
```
# FastAPI 엔드포인트(endpoint) 함수나 API를 호출하여 의도한 결과가 반환되는
# 과정을 검증합니다. 실제 운영 환경과 유사한 조건에서 동작을 확인할 수 있다는
# 점은 장점이지만, 테스팅 환경 구성이 복잡해지기 일쑤입니다.
```

### 종단 테스트 (End to End, E2E Test)

**종단(E2E) 테스트**는 사용자 관점에서 애플리케이션을 실제 시나리오로 구동하여 시스템 전반이 기대대로 동작하는지 검증하는 방식입니다.

UI를 제공하는 웹 애플리케이션을 웹 브라우저로 자동화여 버튼 클릭, 폼 제출, 페이지 전환 등 실제 사용자 동작을 재현합니다.

**특징:**
- 실제 사용자 시나리오 재현
- UI부터 백엔드까지 전체 플로우 검증
- 가장 느리고 설정과 유지 보수가 복잡하며 간헐적 실패(flaky test)가 발생할 가능성이 높음

**도구:**
- Selenium, Playwright 등

### 테스트 피라미드

테스트 종류와 계층 구조를 시각화한 모델입니다:

```
        /\
       /  \
      / E2E\     ← 고비용, 자율, 복잡
     /______\
    /        \
   / 통합 테스트 \
  /____________\
 /              \
/   단위 테스트    \   ← 저비용, 고속, 단순
/__________________\
```

**해석:**
- **단위 테스트**: 가장 많은 양, 빠르고 간단
- **통합 테스트**: 중간 정도의 양과 속도
- **E2E 테스트**: 가장 적은 양, 느리지만 실제 사용자 경험 검증

---

## 테스트 더블

**테스트 더블(Test Double)**은 테스트할 때 실제 환경이나 객체를 대체하는 데 사용하는 가짜 객체나 가짜 구현을 의미합니다.

예를 들어 네트워크 호출이나 데이터베이스 접근이 필요한 코드를 테스트할 때, 실제 데이터베이스나 외부 서비스에 의존하지 않고도 테스트할 수 있는 모의 객체(mock) 또는 스텁(stub)을 사용하면 테스트 속도와 안정성을 개선할 수 있습니다.

### 테스트 더블의 종류

#### 1. 스텁 (Stub)
- **정의**: 고정된 값을 반환하는 가짜 객체로, 외부 의존성을 단순화하여 특정 시나리오를 재현합니다.
- **사용 목적**: 테스트에 필요한 최소한의 응답만 제공

#### 2. 모의 객체 (Mock)
- **정의**: 호출 횟수나 인자 확인이 가능한 객체로, 코드가 특정 방법으로 상호 작용하는지 검증하는 데 유용합니다.
- **사용 목적**: 호출 여부와 방식을 검증

#### 3. 스파이 (Spy)
- **정의**: 모의 객체와 유사하지만, 기존의 실제 객체(또는 기능) 위에 도청(spy)하는 방식으로 동작합니다.
- **사용 목적**: 실제 객체의 메서드를 호출할 수 호출 이력(몇 번 호출되었는지, 어떤 인자와 함께 호출되었는지)을 기록합니다.
- **특징**: 실제 로직을 수행하는 동시에 행동을 관찰할 수 있으므로 실제 코드 동작을 유지하면서 호출 패턴이나 결과를 검증하는 상황에 유용합니다.

#### 4. 가짜 객체 (Fake)
- **정의**: 가짜 구현체입니다.
- **예시**: 인메모리 데이터베이스로 동작하는 데이터베이스 대체물을 사용하여 실제처럼 동작하지만, 가벼운 테스트 환경을 구성합니다.

### 테스트 더블 사용 예시 비교표

| 종류 | 스텁 | 모의 객체 | 스파이 | 가짜 객체 |
|------|------|-----------|--------|-----------|
| **개념** | 미리 준비된 답변으로 응답하는 객체 | 예상되는 호출 동작을 미리 프로그래밍할 수 있는 객체 | 실제 객체의 메서드 호출을 기록하는 래퍼 | 실제 구현을 단순화한 객체 |
| **특징** | 상호 작용은 검증하지 않음 | 실제 객체 동작을 시뮬레이션하고 상호 작용을 검증 | 실제 객체 동작은 유지하면서 호출 정보만 기록 | 실제 구현을 가지며, 주로 데이터베이스나 외부 서비스를 대체할 때 사용 |
| **사용 예** | 다순히 정해진 값을 반환 | Mock과 비슷하지만 실제 구현을 사용 | 메서드 호출을 로깅하고 분석할 때 | 주로 데이터베이스나 외부 서비스를 대체할 때 사용 |

### 언제 사용할까?

유의할 점도 있습니다. 지나치게 남용하면 실제 시스템이 동작하는 것과 괴리가 발생하며, 테스트를 유지 보수하기가 까다롭습니다. 

계다가 테스트 더블 자체가 복잡해지고 많아지면 테스트 코드 가독성이 낮아지기도 합니다.

---

## pytest 사용법

### pytest란?

**pytest**는 파이썬 생태계에서 널리 사용되는 테스트 프레임워크로, 직관적인 문법과 풍부한 플러그인 등으로 테스트 작성과 실행을 단순화합니다.

표준 라이브러리의 unittest 모듈보다 유연하며, 함수 이름과 파일 이름만으로 테스트를 자동 인식하고 실행합니다.

### pytest 주요 특징

1. **간결한 문법**: assert 문을 직접 사용
2. **자동 테스트 발견**: 특정 패턴(`test_*.py` 또는 `*_test.py`)의 파일을 자동 인식
3. **풍부한 플러그인**: 다양한 확장 기능 제공
4. **상세한 실패 리포트**: 어디서 왜 실패했는지 명확한 정보 제공

### 기본 사용법

#### 설치
```bash
pip install pytest
```

#### 테스트 파일 작성
```python
# test_example.py

def add(a, b):
    return a + b

def test_add():
    assert add(2, 3) == 5
    assert add(-1, 1) == 0
    assert add(0, 0) == 0
```

#### 테스트 실행
```bash
# 현재 디렉터리의 모든 테스트 실행
pytest

# 특정 파일만 실행
pytest test_example.py

# 상세 출력 모드
pytest -v

# 특정 테스트 함수만 실행
pytest test_example.py::test_add
```

### pytest 주요 기능

#### 1. Fixture
테스트에 필요한 사전 설정이나 데이터를 준비하는 기능

```python
import pytest

@pytest.fixture
def sample_data():
    return {"name": "테스트", "value": 42}

def test_with_fixture(sample_data):
    assert sample_data["name"] == "테스트"
    assert sample_data["value"] == 42
```

#### 2. 파라미터화 테스트
여러 입력값으로 같은 테스트를 반복

```python
import pytest

@pytest.mark.parametrize("a, b, expected", [
    (1, 2, 3),
    (0, 0, 0),
    (-1, 1, 0),
    (10, 5, 15),
])
def test_add_parametrized(a, b, expected):
    assert add(a, b) == expected
```

#### 3. 예외 테스트
특정 예외가 발생하는지 검증

```python
def divide(a, b):
    if b == 0:
        raise ValueError("0으로 나눌 수 없습니다")
    return a / b

def test_divide_by_zero():
    with pytest.raises(ValueError):
        divide(10, 0)
```

### pytest 실행 옵션

```bash
# 실패한 테스트만 재실행
pytest --lf

# 가장 먼저 실패한 테스트에서 중단
pytest -x

# 커버리지 리포트와 함께 실행 (pytest-cov 플러그인 필요)
pytest --cov=myproject

# 마커로 특정 테스트만 실행
pytest -m slow  # @pytest.mark.slow로 표시된 테스트만
```

---

## 참고 자료

- pytest 공식 문서: https://docs.pytest.org/
- 테스트 피라미드 개념: Martin Fowler's Testing Pyramid
- 테스트 더블 패턴: Gerard Meszaros의 "xUnit Test Patterns"
